# Домашнее задание 20 + 25 + 27

## ЗАДАЧА 20

Сделайте ваш чат сетевым, то есть доработайте его так, чтобы два экземпляра программы могли отправлять и принимать сообщения между собой.

Используйте протокол UDP или TCP на свое усмотрение.

Можно использовать архитектуру клиент-сервер, в этом случае будут две программы — клиент и сервер.
Можно использовать децентрализованную (англ. peer-to-peer, P2P — равный к равному) сеть, в которой каждый узел является как клиентом, так и выполняет функции сервера.
Проект чата следует загрузить в свой репозиторий на GitHub. 

## Рейлизация:
Разработано приложение для сервера -> директория ServerTCP
разработано прилодение для клиента -> директория Project

## компиляция
скачать проект на компьютер
из директори и со скаченым проектом выполнить:
### make -f makeFile ( это соберет исполняемый файл для клиентсого приложения)
### make -f makeFile_Server (это соберет исполняемый файл для серверного приложения)
запустить сервер.
далее можно запускать клиенты несколько.

сервер отслеживает подключение и отключение клиентов на что выводит сообщения.

Для того чтобы завершить работу сервера надо ввести 'q'и ввод.

# ДЗ 25
### задача
    организовать хранение данных чата в базе данных.

Для работы сервера необходимо чтобы был установлен mysql! 

реализованны все методы для работы чата.

# ДЗ 27
### Задача
Добавьте в ваш проект чата логгирование сообщений от других участников чата и своих сообщений.

Для этого напишите класс Logger, через который будет проходить вся работа с файлом логов.
Сохраняйте сообщения в файл на диске, можете назвать его log.txt.
При создании объекта логгера должно производиться открытие файла, а при его разрушении — закрытие файла (концепт RAII).

Реализуйте в классе два метода:

1. запись строки логов в файл;
2. чтение одной строки из файла.
3. 
Конечно же, запись и чтение должны быть потокобезопасными — при одновременном вызове нескольких потоков с записью в файл и чтением из файла, не должно происходить взаимоблокировок и гонок данных.

Не забывайте про принципы инкапсуляции: код, пользующийся вашими методами чтения и записи, не должен знать про многопоточность.

### реализовано:
 1. class MessageLogger
 2. Методы:
            void saveMessageLog(const Message &message);
            std::string loadMessageLogLine();
 3. использован shared_mutex
                В методе записи shared_mutex.lock() для полной блокировки записи в файл из нескольких потоков
                В методе чтения shared_mutex.lock_shared() для возможности чтения из разных потоков


